name: Manual Check URL -> TG -> Reboot -> TG

on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Check URL + notify + reboot
        env:
          SITE_URL: ${{ secrets.SITE_URL }}
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
          REBOOT_WEBHOOK_URL: ${{ secrets.REBOOT_WEBHOOK_URL }}
          REBOOT_SECRET: ${{ secrets.REBOOT_SECRET }}
          MUST_CONTAIN: ${{ secrets.MUST_CONTAIN }}
        run: |
          python3 - << 'PY'
          import os, urllib.request, urllib.parse, urllib.error

          SITE_URL = os.environ["SITE_URL"]
          TG_TOKEN = os.environ["TG_TOKEN"]
          TG_CHAT_ID = os.environ["TG_CHAT_ID"]
          REBOOT_WEBHOOK_URL = os.environ["REBOOT_WEBHOOK_URL"]
          REBOOT_SECRET = os.environ["REBOOT_SECRET"]
          MUST_CONTAIN = os.environ.get("MUST_CONTAIN") or ""

          def tg_send(text):
              api = f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
              data = urllib.parse.urlencode({"chat_id": TG_CHAT_ID, "text": text}).encode()
              with urllib.request.urlopen(api, data=data, timeout=20) as r:
                  body = r.read().decode("utf-8","ignore")
                  print("TG response:", body)

          def http_ok(url, timeout=20):
              try:
                  req = urllib.request.Request(url, method="GET", headers={"User-Agent":"mite-watchdog/1.0"})
                  with urllib.request.urlopen(req, timeout=timeout) as r:
                      code = r.getcode()
                      if not (200 <= code < 400):
                          return False, f"HTTP {code}"
                      if MUST_CONTAIN:
                          body = r.read(250_000).decode("utf-8", errors="ignore")
                          if MUST_CONTAIN not in body:
                              return False, f"keyword '{MUST_CONTAIN}' not found"
                      return True, f"HTTP {code}"
              except urllib.error.HTTPError as e:
                  return False, f"HTTPError {e.code}"
              except Exception as e:
                  return False, f"Error {type(e).__name__}: {e}"

          def call_reboot_webhook():
              # Ð’ÐÐ–ÐÐž: Ð·Ð´ÐµÑÑŒ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ ?key=...  (ÐµÑÐ»Ð¸ Ñƒ Ñ‚ÐµÐ±Ñ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ â€” Ð¿Ð¾Ð¼ÐµÐ½ÑÐ¹ key)
              sep = "&" if "?" in REBOOT_WEBHOOK_URL else "?"
              url = f"{REBOOT_WEBHOOK_URL}{sep}key={urllib.parse.quote(REBOOT_SECRET)}"

              try:
                  req = urllib.request.Request(url, method="POST", headers={"User-Agent":"mite-watchdog/1.0"})
                  with urllib.request.urlopen(req, timeout=25) as r:
                      body = r.read(2000).decode("utf-8","ignore")
                      return True, f"{r.getcode()} {body}"
              except urllib.error.HTTPError as e:
                  body = e.read(2000).decode("utf-8","ignore")
                  return False, f"HTTPError {e.code} {body}"
              except Exception as e:
                  return False, f"Error {type(e).__name__}: {e}"

          print("Checking:", SITE_URL)
          ok, info = http_ok(SITE_URL)

          if ok:
              tg_send(f"âœ… UP: {SITE_URL} ({info}). Reboot ÐÐ• Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÑŽ.")
              raise SystemExit(0)

          tg_send(f"âŒ DOWN: {SITE_URL} ({info}). Ð—Ð°Ð¿ÑƒÑÐºÐ°ÑŽ rebootâ€¦")
          reboot_ok, reboot_info = call_reboot_webhook()

          if reboot_ok:
              tg_send(f"ðŸ” REBOOT OK: {reboot_info}")
              raise SystemExit(0)
          else:
              tg_send(f"âš ï¸ REBOOT FAILED: {reboot_info}")
              raise SystemExit(1)
          PY
