name: MITE Watchdog

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: mite-watchdog
  cancel-in-progress: false

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure state file
        run: |
          if [ ! -f state.json ]; then
            echo '{"down_since": null, "last_alert_min": null, "rebooted": false}' > state.json
          fi

      - name: Monitor + Telegram + Reboot after 20 min
        env:
          SITE_URL: ${{ secrets.SITE_URL }}
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
          REBOOT_WEBHOOK_URL: ${{ secrets.REBOOT_WEBHOOK_URL }}
          REBOOT_SECRET: ${{ secrets.REBOOT_SECRET }}
          MUST_CONTAIN: ${{ secrets.MUST_CONTAIN }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
        run: |
          python3 - << 'PY'
          print("EVENT:", os.environ.get("GITHUB_EVENT_NAME"))

          import json, os, time
          import urllib.request, urllib.parse, urllib.error

          SITE_URL = os.environ["SITE_URL"]
          TG_TOKEN = os.environ["TG_TOKEN"]
          TG_CHAT_ID = os.environ["TG_CHAT_ID"]
          REBOOT_WEBHOOK_URL = os.environ["REBOOT_WEBHOOK_URL"]
          REBOOT_SECRET = os.environ["REBOOT_SECRET"]
          MUST_CONTAIN = os.environ.get("MUST_CONTAIN") or ""

          now = int(time.time())

          def tg_send(text):
              api = f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
              data = urllib.parse.urlencode({"chat_id": TG_CHAT_ID, "text": text}).encode()
              try:
                  urllib.request.urlopen(api, data=data, timeout=20).read()
              except Exception as e:
                  print("TG send failed:", e)

          def http_ok(url, timeout=20):
              try:
                  req = urllib.request.Request(url, method="GET", headers={"User-Agent":"mite-watchdog/1.0"})
                  with urllib.request.urlopen(req, timeout=timeout) as r:
                      code = r.getcode()
                      if not (200 <= code < 400):
                          return False, f"HTTP {code}"
                      if MUST_CONTAIN:
                          body = r.read(250_000).decode("utf-8", errors="ignore")
                          if MUST_CONTAIN not in body:
                              return False, f"keyword '{MUST_CONTAIN}' not found"
                      return True, f"HTTP {code}"
              except urllib.error.HTTPError as e:
                  return False, f"HTTPError {e.code}"
              except Exception as e:
                  return False, f"Error {type(e).__name__}: {e}"

          def minutes_since(ts):
              return int((now - ts) / 60)

          def call_reboot_webhook():
              sep = "&" if "?" in REBOOT_WEBHOOK_URL else "?"
              url = f"{REBOOT_WEBHOOK_URL}{sep}key={urllib.parse.quote(REBOOT_SECRET)}"
              try:
                  req = urllib.request.Request(url, method="POST", headers={"User-Agent":"mite-watchdog/1.0"})
                  with urllib.request.urlopen(req, timeout=25) as r:
                      body = r.read(2000).decode("utf-8","ignore")
                      print("Reboot webhook:", r.getcode(), body)
                      return True
              except urllib.error.HTTPError as e:
                  body = e.read(2000).decode("utf-8","ignore")
                  print("Reboot webhook HTTPError:", e.code, body)
                  return False
              except Exception as e:
                  print("Reboot webhook error:", e)
                  return False

          # load state
          with open("state.json", "r", encoding="utf-8") as f:
              st = json.load(f)

          ok, info = http_ok(SITE_URL)
          print("Checking:", SITE_URL, "=>", ok, info, "STATE:", st)

          if ok:
              if st.get("down_since") is not None:
                  down_min = minutes_since(st["down_since"])
                  tg_send(f"‚úÖ UP: {SITE_URL} –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ë—ã–ª DOWN ~{down_min} –º–∏–Ω.")
              st = {"down_since": None, "last_alert_min": None, "rebooted": False}

          else:
              if st.get("down_since") is None:
                  st["down_since"] = now
                  st["last_alert_min"] = 0
                  st["rebooted"] = False
                  tg_send(f"‚ùå DOWN: {SITE_URL} ({info}) (0 –º–∏–Ω)")
              else:
                  down_min = minutes_since(st["down_since"])
                  last = st.get("last_alert_min")

                  # –ø–æ–≤—Ç–æ—Ä–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
                  if last is None or down_min >= last + 5:
                      st["last_alert_min"] = down_min
                      tg_send(f"‚ùå STILL DOWN: {SITE_URL} ({info}) (~{down_min} –º–∏–Ω)")

                  # reboot —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ 20 –º–∏–Ω—É—Ç DOWN –∏ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
                  if (not st.get("rebooted")) and down_min >= 20:
                      if call_reboot_webhook():
                          st["rebooted"] = True
                          tg_send(f"üö® REBOOT triggered: {SITE_URL} DOWN ~{down_min} –º–∏–Ω")
                      else:
                          tg_send(f"‚ö†Ô∏è REBOOT FAILED: {SITE_URL} DOWN ~{down_min} –º–∏–Ω (—Å–º. logs)")

          with open("state.json", "w", encoding="utf-8") as f:
              json.dump(st, f, ensure_ascii=False, indent=2)
          PY

      - name: Commit state
        run: |
          git config user.name "mite-watchdog"
          git config user.email "actions@users.noreply.github.com"
          git add state.json
          git commit -m "Update watchdog state" || echo "No changes"
          git push
